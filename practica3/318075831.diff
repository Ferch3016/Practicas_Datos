diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index e04bda5..9cf86be 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -29,7 +29,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         protected Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
 
         /**
@@ -38,7 +38,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+            return (padre!= null);
         }
 
         /**
@@ -47,7 +47,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+            return (izquierdo!= null);
         }
 
         /**
@@ -56,7 +56,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+            return (derecho!= null);
         }
 
         /**
@@ -65,8 +65,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
         @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
-        }
+            if (padre == null) 
+			throw new NoSuchElementException();
+
+		return padre;
+    }
 
         /**
          * Regresa el izquierdo del vértice.
@@ -74,8 +77,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
-        }
+            if (izquierdo == null) 
+			throw new NoSuchElementException();
+
+		    return izquierdo;
+    }
 
         /**
          * Regresa el derecho del vértice.
@@ -83,7 +89,22 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
         @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+            if (derecho == null)
+			throw new NoSuchElementException();
+            return derecho;
+    }
+        
+
+        //Auxiliar para altura
+        private int altura(Vertice v) {
+            if (v == null) 
+                return -1;
+            int alturaIzq = altura(v.izquierdo) + 1;
+            int alturaDer = altura(v.derecho) + 1;
+    
+            if (alturaIzq >= alturaDer) 
+                return alturaIzq;
+            return alturaDer;
         }
 
         /**
@@ -91,7 +112,16 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+        return altura(this);
+    }
+
+
+        //Auxiliar para la profundidad
+        private int profundidad(Vertice v) {
+            if (v == raiz) 
+                return 0;
+    
+            return profundidad(v.padre) + 1;
         }
 
         /**
@@ -99,15 +129,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
-        }
+        return profundidad(this);    
+    }
 
         /**
          * Regresa el elemento al que apunta el vértice.
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+            return elemento;
         }
 
         /**
@@ -124,15 +154,31 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
-        }
+        if (this == null || vertice == null)
+		    return false;
+
+	    if (elemento == null && vertice.elemento == null)
+		    return true;
+
+	    boolean izq = true;
+	    if (izquierdo != null) {
+		    izq = izquierdo.equals(vertice.izquierdo);
+	    }
+
+	    boolean der = true;
+	    if (derecho != null) {
+		    der = derecho.equals(vertice.derecho);
+	    }
+
+	    return (elemento != null && elemento.equals(vertice.elemento) && der && izq);
+    }
 
         /**
          * Regresa una representación en cadena del vértice.
          * @return una representación en cadena del vértice.
          */
         @Override public String toString() {
-            // Aquí va su código.
+            return String.format("%s", elemento);
         }
     }
 
@@ -153,8 +199,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
-    }
+        for (T e : coleccion) 
+    		agrega(e);
+	    }	
+    
 
     /**
      * Construye un nuevo vértice, usando una instancia de {@link Vertice}. Para
@@ -169,13 +217,29 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
         return new Vertice(elemento);
     }
 
+
+    //Auxiliar de la altura con vértices-
+    private int altura(Vertice v) {
+	    if (v == null) 
+		    return -1;
+
+	    int alturaIzq = altura(v.izquierdo) + 1;
+	    int alturaDer = altura(v.derecho) + 1;
+	    if (alturaIzq >= alturaDer) 
+		    return alturaIzq;
+	    return alturaDer;
+    }	
+
     /**
      * Regresa la altura del árbol. La altura de un árbol es la altura de su
      * raíz.
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        if (raiz == null)
+		    return -1;
+
+	    return altura(raiz);
     }
 
     /**
@@ -183,7 +247,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -193,7 +257,31 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return (busca(elemento) != null);
+    }
+
+    //Auxiliar para busca
+    private Vertice busca(T elemento, Vertice vertice) {
+	    if (vertice == null) 
+		    return null;
+
+	    if (elemento.equals(vertice.elemento)) 
+		    return vertice;
+
+	    Vertice tempo;
+	    if (vertice.izquierdo != null) {
+		    tempo = busca(elemento, vertice.izquierdo);
+		    if (tempo != null)
+			    return tempo;
+	    }
+
+	    if (vertice.derecho != null) {
+		    tempo = busca(elemento, vertice.derecho);
+		    if (tempo != null) 
+			    return tempo;
+	    }
+
+	    return null;
     }
 
     /**
@@ -204,8 +292,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>null</code> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
-    }
+        return busca(elemento, raiz);
+ }
 
     /**
      * Regresa el vértice que contiene la raíz del árbol.
@@ -213,8 +301,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
-    }
+        if (raiz == null) 
+		    throw new NoSuchElementException();
+
+	    return raiz;
+ }
 
     /**
      * Nos dice si el árbol es vacío.
@@ -222,14 +313,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return (raiz == null);
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        raiz = null;
+	    elementos = 0;
     }
 
     /**
@@ -243,15 +335,75 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+            if (arbol == this) 
+            return true;
+        if (this == null || arbol == null)
+            return false;
+        if (raiz == arbol.raiz)
+            return true;
+    
+        return raiz.equals(arbol.raiz);
+ }
+
+
+    //Auxiliares para el toString-
+    private String ponleEspacio(int nivel, int[] arreglo) {
+	    String e = "";
+
+	    for (int i = 0; i < nivel; i++) {
+		    if (arreglo[i] == 1) {
+			    e += "│  ";
+		    }else{
+			    e += "   ";
+		    }
+	    }
+	    return e;
     }
 
+    private String toString(Vertice v, int nivel, int[] arreglo) {
+	    String e = v.toString() + "\n";
+
+	    arreglo[nivel] = 1;
+
+	    if (v.izquierdo != null && v.derecho != null) {
+		    e += ponleEspacio(nivel, arreglo);
+		    e += "├─›";
+		    e += toString(v.izquierdo, nivel + 1, arreglo);
+		    e += ponleEspacio(nivel, arreglo);
+		    e += "└─»";
+		    arreglo[nivel] = 0;
+		    e += toString(v.derecho, nivel + 1, arreglo);
+	    } else if (v.izquierdo != null) {
+		    e += ponleEspacio(nivel, arreglo);
+		    e += "└─›";
+		    arreglo[nivel] = 0;
+		    e += toString(v.izquierdo, nivel + 1, arreglo);
+	    } else if (v.derecho != null) {
+		    e += ponleEspacio(nivel, arreglo);
+		    e += "└─»";
+		    arreglo[nivel] = 0;
+		    e += toString(v.derecho, nivel + 1, arreglo);
+	    }
+	    return e;
+    }
+
+    private String toString(ArbolBinario<T> arbol) {
+	    if (arbol.raiz == null) 
+		    return "";
+
+	    int[] arreglo = new int[arbol.altura() + 1];
+	    for ( int i = 0; i < arbol.altura() + 1; i++) {
+		    arreglo[i] = 0;
+	    }
+
+	    return toString(arbol.raiz, 0, arreglo);
+    }
     /**
      * Regresa una representación en cadena del árbol.
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        return toString(this);
     }
 
     /**
@@ -266,4 +418,4 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
     protected Vertice vertice(VerticeArbolBinario<T> vertice) {
         return (Vertice)vertice;
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 651a4da..75e6ac0 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -18,17 +18,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Inicializa al iterador. */
         private Iterador() {
-            // Aquí va su código.
-        }
+            cola = new Cola<Vertice>();
+		    if (raiz != null) {
+			cola.mete(raiz);
+		}
+    }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+        Vertice tempo;
+		tempo = cola.saca();
+		if (tempo.izquierdo != null)
+			cola.mete(tempo.izquierdo);
+
+		if (tempo.derecho != null) 
+			cola.mete(tempo.derecho);
+
+		return tempo.elemento;
+		
         }
     }
 
@@ -38,6 +50,47 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      */
     public ArbolBinarioCompleto() { super(); }
 
+
+    //Auxiliares para conseguir el ultimo elemento y el vertice sin hijos
+    private Vertice getUltimoEleme(Vertice v) {
+	    Cola<Vertice> cola = new Cola<Vertice>();
+	    cola.mete(v);
+	    while (!cola.esVacia()) {
+		Vertice tempo = cola.saca();
+		if (tempo.izquierdo != null)
+			cola.mete(tempo.izquierdo);
+		if (tempo.derecho != null)
+			cola.mete(tempo.derecho);
+
+		if (cola.esVacia())
+			return tempo;
+	    }
+
+	    return null;
+    }
+
+    private Vertice getPrimVertiSinHij(Vertice v) {
+	    Cola<Vertice> cola = new Cola<Vertice>();
+	    cola.mete(v);
+	    while (!cola.esVacia()) {
+		    Vertice tempo;
+		    tempo = cola.saca();
+		    if (tempo.izquierdo == null) {
+			    return tempo;
+		    } else {
+			    cola.mete(tempo.izquierdo);
+		    }
+
+		    if (tempo.derecho == null) {
+			    return tempo;
+		    } else { 
+			    cola.mete(tempo.derecho);
+		    }
+	    }
+
+	    return null;
+    }
+
     /**
      * Construye un árbol binario completo a partir de una colección. El árbol
      * binario completo tiene los mismos elementos que la colección recibida.
@@ -56,9 +109,45 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+		throw new IllegalArgumentException();
+
+    	Vertice n = nuevoVertice(elemento);
+	        elementos++;
+
+	if (raiz == null) {
+		raiz = n;
+	}else{
+		Vertice f = getPrimVertiSinHij(raiz);
+
+		if ((elementos) % 2 == 0) {
+			f.izquierdo = n;
+			n.padre = f;
+		}else{
+			f.derecho = n;
+			n.padre = f;
+		}
+	}
+ }
+    
+    //Auxiliar para cambiar los vértices:
+    private void cambia(Vertice a, Vertice ultimo) {
+        T e = a.elemento;
+
+        a.elemento = ultimo.elemento;
+        ultimo.elemento = e;
+}
+
+    //Auxiliar para saber si hay un hijo izquuierdo
+    private boolean hayIzq(Vertice v) {
+	    if (v == null)
+		    return false;
+	    if (v.padre.izquierdo.equals(v)) 
+		    return true;
+	    return false;
     }
 
+
     /**
      * Elimina un elemento del árbol. El elemento a eliminar cambia lugares con
      * el último elemento del árbol al recorrerlo por BFS, y entonces es
@@ -66,17 +155,37 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
-    }
+        Vertice v = (Vertice) busca(elemento);
+
+	if (v == null)
+		return;
+
+	elementos--;
+	if (elementos == 0) {
+		raiz = null;
+	}else{
+		Vertice f = getUltimoEleme(raiz);
+		cambia(v,f);
+
+		if (hayIzq(f)) {
+			f.padre.izquierdo = null;
+		}else{
+			f.padre.derecho = null;
+		}
+
+	}
+}
 
     /**
      * Regresa la altura del árbol. La altura de un árbol binario completo
      * siempre es ⌊log<sub>2</sub><em>n</em>⌋.
      * @return la altura del árbol.
      */
-    @Override public int altura() {
-        // Aquí va su código.
-    }
+    @Override public int altura(){
+        if (raiz == null) 
+		return -1;
+	return (int) Math.floor(Math.log(elementos)/Math.log(2));
+}
 
     /**
      * Realiza un recorrido BFS en el árbol, ejecutando la acción recibida en
@@ -84,8 +193,21 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (raiz == null)
+        return;
+    Cola <Vertice> cola = new Cola<Vertice>();
+    cola.mete(raiz);
+    while (!cola.esVacia()) {
+        Vertice tempo;
+        tempo = cola.saca();
+        accion.actua(tempo);
+        if (tempo.izquierdo != null) 
+            cola.mete(tempo.izquierdo);
+        if (tempo.derecho != null) 
+            cola.mete(tempo.derecho);
+
     }
+}
 
     /**
      * Regresa un iterador para iterar el árbol. El árbol se itera en orden BFS.
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index 5e014ab..079840c 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -25,19 +25,36 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
         /* Inicializa al iterador. */
         private Iterador() {
-            // Aquí va su código.
-        }
+        pila = new Pila<Vertice>();
+		Vertice n = raiz;
+
+		while (n != null) {
+			pila.mete(n);
+			n = n.izquierdo;
+		}
+    }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
-        }
-    }
+        Vertice tempo = pila.saca();
+		T e = tempo.elemento;
+		if (tempo.derecho != null) {
+			pila.mete(tempo.derecho);
+			tempo = tempo.derecho.izquierdo;
+			while (tempo != null) {
+				pila.mete(tempo);
+				tempo = tempo.izquierdo;
+			}
+		}
+		return e;
+	}
+}
+    
 
     /**
      * El vértice del último elemento agegado. Este vértice sólo se puede
@@ -64,13 +81,44 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
         super(coleccion);
     }
 
+    //Auxiliar para agrega
+    private void agrega(Vertice a, Vertice n) {
+	    if ( a == null )
+		    return;
+
+	    if ( n.elemento.compareTo(a.elemento) <= 0 ) {
+		    if ( a.izquierdo == null ) {
+			    a.izquierdo = n;
+			    n.padre = a;
+		    } else {
+			    agrega(a.izquierdo, n);
+		    }
+	    } else {
+		    if ( a.derecho == null ) {
+			    a.derecho = n;
+			    n.padre = a;
+		    } else {
+			    agrega(a.derecho, n);
+		    }
+	    }
+    }
+
     /**
      * Agrega un nuevo elemento al árbol. El árbol conserva su orden in-order.
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
-    }
+        if (elemento == null)
+		throw new IllegalArgumentException();
+    	Vertice n = nuevoVertice(elemento);
+	    elementos++;
+	    ultimoAgregado = n;
+        if (raiz == null) {
+		raiz = n;
+	    }else{
+		agrega(raiz, n);
+	}
+}
 
     /**
      * Elimina un elemento. Si el elemento no está en el árbol, no hace nada; si
@@ -79,7 +127,24 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+		return;
+
+	Vertice n = (Vertice) busca(elemento);
+	if (n == null)
+		return;
+	elementos--;
+	if (n.izquierdo != null && n.derecho != null) {
+		n = cambia(n);
+    	}
+	eliminaVertice(n);
+}
+
+    // Auxiliar para intercambia
+    private Vertice maximoEnSubArbol(Vertice v) {
+	    if (v.derecho == null)
+		    return v;
+	    return maximoEnSubArbol(v.derecho);
     }
 
     /**
@@ -91,10 +156,23 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         intercambió. El vértice regresado tiene a lo más un hijo distinto
      *         de <code>null</code>.
      */
-    protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        protected Vertice cambia(Vertice vertice) {
+        Vertice max = maximoEnSubArbol(vertice.izquierdo);
+	    T e = vertice.elemento;
+	    vertice.elemento = max.elemento;
+	    max.elemento = e;
+	    return max;
     }
 
+    //Auxiliar para eliminar vertices
+    private boolean hayIzq(Vertice vertice) {
+	    if (vertice == null) 
+		    return false;
+
+	    if (vertice.equals(vertice.padre.izquierdo))
+			   return true;
+	    return false;
+    }
     /**
      * Elimina un vértice que a lo más tiene un hijo distinto de
      * <code>null</code> subiendo ese hijo (si existe).
@@ -102,9 +180,42 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *                distinto de <code>null</code>.
      */
     protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+        Vertice padre = vertice.padre;
+	    Vertice hijo;
+	    if (vertice.izquierdo != null)
+		    hijo = vertice.izquierdo;
+	    else 
+		    hijo = vertice.derecho;
+
+	    if (padre != null) {
+		    if (hayIzq(vertice)) 
+			    padre.izquierdo = hijo;
+		    else 
+			    padre.derecho = hijo;
+	    }else{
+		    raiz = hijo;
+	    }
+
+	    if (hijo != null)
+		    hijo.padre = padre;
     }
 
+
+    //Auxiliar para buscar
+    private Vertice busca(T elemento, Vertice v) {
+        if (v == null)
+            return null;
+    
+        if (v.elemento.equals(elemento))
+            return v;
+    
+        if ( v.elemento.compareTo(elemento) > 0) {
+            return busca(elemento, v.izquierdo);
+            }else{ 
+            return busca(elemento, v.derecho);
+        }
+}
+
     /**
      * Busca un elemento en el árbol recorriéndolo in-order. Si lo encuentra,
      * regresa el vértice que lo contiene; si no, regresa <code>null</code>.
@@ -113,7 +224,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         encuentra; <code>null</code> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(elemento, raiz);
     }
 
     /**
@@ -128,7 +239,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         elemento al árbol.
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
-        // Aquí va su código.
+        return ultimoAgregado;
     }
 
     /**
@@ -136,8 +247,27 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * tiene hijo izquierdo, el método no hace nada.
      * @param vertice el vértice sobre el que vamos a girar.
      */
-    public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+    public void giraDerecha(VerticeArbolBinario<T> vertice){
+        Vertice v = (Vertice) vertice;
+	    if (v.izquierdo == null || v == null) 
+		    return;
+	    Vertice izquierdo = v.izquierdo;
+	    izquierdo.padre = v.padre;
+	    if (v.padre != null){
+		    if (v.equals(v.padre.izquierdo)) {
+			    v.padre.izquierdo = izquierdo;
+		    }else{ 
+			    v.padre.derecho = izquierdo;
+		    }
+	    }else{
+		    raiz = izquierdo;
+	    }
+        v.padre = izquierdo;
+	    v.izquierdo = izquierdo.derecho; 
+	    if (v.izquierdo != null){
+		    izquierdo.derecho.padre = v;
+	    }
+	    izquierdo.derecho = v;
     }
 
     /**
@@ -146,7 +276,35 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        Vertice v = (Vertice) vertice;
+	    if (v.derecho == null || v == null)
+		    return;
+	    Vertice derecho = v.derecho;
+	    derecho.padre = v.padre;
+	    if (v.padre != null) {
+		    if (v.equals(v.padre.izquierdo)){ 
+			    v.padre.izquierdo = derecho;
+		    }else{
+			    v.padre.derecho = derecho;
+		    } 
+	    }else{ 
+		    raiz = derecho;
+	    } 
+        v.padre = derecho;
+	    v.derecho = derecho.izquierdo;
+	    if (v.derecho != null) {
+		    derecho.izquierdo.padre = v;
+	    }
+        derecho.izquierdo = v;
+    }
+
+    //Auxiliar para el DFS
+    private void dfsPreOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+	    if ( v == null )
+		    return;
+	    accion.actua(v);
+	    dfsPreOrder(accion, v.izquierdo);
+	    dfsPreOrder(accion, v.derecho);
     }
 
     /**
@@ -155,7 +313,16 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPreOrder(accion, raiz);
+    }
+
+    //Auxiliar para DFS pero in order
+    private void dfsInOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+	    if (v == null)
+		    return;
+        dfsInOrder(accion, v.izquierdo);
+	    accion.actua(v);
+	    dfsInOrder(accion, v.derecho);
     }
 
     /**
@@ -164,7 +331,17 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsInOrder(accion, raiz);
+    }
+
+    //Auxiliar para DFS 
+    private void dfsPostOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+	    if (v == null)
+		    return;
+
+	    dfsPostOrder(accion, v.izquierdo);
+	    dfsPostOrder(accion, v.derecho);
+	    accion.actua(v);
     }
 
     /**
@@ -173,7 +350,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPostOrder(accion, raiz);
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..f386627 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -11,18 +11,53 @@ public class Arreglos {
     private Arreglos() {}
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordenar el arreglo.
      */
+
+    //Auxiliares para quicksort
+    private static <T> void
+    intercambia(T[] arreglo, int c, int b){
+        T a = arreglo [c];
+        arreglo[c] = arreglo[b];
+        arreglo[b] = a;
+}
+    
+    private static <T> void
+    quickSort(T[] arreglo, int ini, int fini, Comparator<T> comparador){
+        if(fini <= ini){
+            return;
+            
+        }
+        int i = ini+1;
+        int j= fini;
+        while(i < j){
+            if(comparador.compare(arreglo[i], arreglo[ini])>0 && comparador.compare(arreglo[j], arreglo[ini]) <= 0) {
+            intercambia(arreglo, i, j);
+            i = i+1;
+            j= j-1;
+            }else if(comparador.compare(arreglo[i], arreglo[ini]) <= 0){
+                i = i+1;
+            }else{
+                j= j-1;
+            }
+        
+        }
+        if(comparador.compare(arreglo[i], arreglo[ini]) > 0) i = i-1;
+        intercambia(arreglo, ini, i);
+        quickSort(arreglo, ini, i-1, comparador);
+        quickSort(arreglo, i+1, fini, comparador);
+}
+
     public static <T> void
     quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+        quickSort(arreglo, 0, arreglo.length -1, comparador);
     }
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
@@ -39,7 +74,15 @@ public class Arreglos {
      */
     public static <T> void
     selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+        for ( int i = 0; i < arreglo.length; i++ ) {
+            int m = i;
+            for ( int j = i + 1; j < arreglo.length; j++ ) {
+                if (comparador.compare(arreglo[j], arreglo[m]) < 0 )
+                    m = j;
+            }
+    
+            intercambia(arreglo, i, m);
+        }
     }
 
     /**
@@ -63,7 +106,22 @@ public class Arreglos {
      */
     public static <T> int
     busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        int maxi = arreglo.length - 1;
+        int mini = 0;
+	    int supo;
+
+	    while (mini < maxi + 1) {
+		    supo = mini + (maxi - mini) / 2;
+		    if (comparador.compare(arreglo[supo], elemento) == 0) 
+				    return supo;
+	 	    if (comparador.compare(elemento, arreglo[supo]) < 0) {
+			    maxi = supo - 1;
+		    }else{
+			    mini = supo + 1;
+		    }
+	    }
+
+	    return -1;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..671a57c 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -10,8 +10,19 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
-        // Aquí va su código.
-    }
+        if (esVacia())
+		return "";
+
+	    String ne = "";
+	    Nodo n = cabeza;
+
+	    while (n != null) {
+		ne += n.elemento.toString() + ",";
+		n = n.siguiente;
+	} 
+	
+	return ne;
+}
 
     /**
      * Agrega un elemento al final de la cola.
@@ -20,6 +31,16 @@ public class Cola<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) 
+		throw new IllegalArgumentException("No hay nada que agregar");
+	
+	    Nodo n = new Nodo(elemento);
+
+	    if (rabo == null) {
+		rabo = cabeza = n;
+	    }else{
+		    rabo.siguiente = n;
+		    rabo = n;
+	    }
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index ace1fe8..f551649 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,7 +28,7 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         private Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
     }
 
@@ -41,37 +41,47 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         private Iterador() {
-            // Aquí va su código.
+            siguiente = cabeza;
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return siguiente != null;
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
-            // Aquí va su código.
+            if(siguiente == null)
+            throw new NoSuchElementException("No hay un elemento después");
+            anterior = siguiente;
+            siguiente = siguiente.siguiente;
+            return anterior.elemento;
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return anterior != null;
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
-            // Aquí va su código.
+            if(anterior == null)
+            throw new NoSuchElementException("No hay ningun elemento antes");
+            siguiente = anterior;
+            anterior = anterior.anterior;
+            return siguiente.elemento;
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            this.siguiente = cabeza;
+            this.anterior = null;
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            this.siguiente = null;
+            this.anterior = rabo;
         }
     }
 
@@ -88,7 +98,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -97,7 +107,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -106,7 +116,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -118,7 +128,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+        throw new IllegalArgumentException("No hay nada que agregar");
+        longitud ++;
+        Nodo n = new Nodo(elemento);
+        if(rabo == null) {
+            cabeza = rabo = n;
+        }else{
+            rabo.siguiente = n;
+            n.anterior = rabo;
+            rabo = n;
+        }
     }
 
     /**
@@ -129,7 +149,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+        throw new IllegalArgumentException("No hay nada que agregar");
+        longitud ++;
+        Nodo n = new Nodo(elemento);
+        if(rabo == null){
+            cabeza = rabo = n;
+        }else{
+            rabo.siguiente = n;
+            n.anterior = rabo;
+            rabo = n;
+        }
     }
 
     /**
@@ -140,7 +170,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+        throw  new IllegalArgumentException("No hay nada que agregar");
+        longitud ++;
+        Nodo n = new Nodo(elemento);
+        if(cabeza == null){
+            cabeza = rabo = n;
+        }else{
+            n.siguiente = cabeza;
+            cabeza.anterior = n;
+            cabeza = n;
+        }
     }
 
     /**
@@ -159,7 +199,28 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+        throw new IllegalArgumentException("No hay nada que insertar");
+        if(i <= 0) {
+            agregaInicio(elemento);
+    
+        } else if (i >= longitud){
+         agregaFinal(elemento);
+            
+        }else{
+            Nodo esteNodo = cabeza;
+            int r = 0;
+            this.longitud++;
+            while(r != i){
+                esteNodo = esteNodo.siguiente;
+                r++;
+            }
+            Nodo n = new Nodo(elemento);
+            n.siguiente = esteNodo;
+            n.anterior = esteNodo.anterior;
+            esteNodo.anterior = n;
+            n.anterior.siguiente = n;
+        }
     }
 
     /**
@@ -168,7 +229,26 @@ public class Lista<T> implements Coleccion<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if(cabeza != null){
+            Nodo n = cabeza;
+            while(n != null){
+                if(n.elemento.equals(elemento)) 
+                    break;
+                n = n.siguiente;
+            }
+            if(n == null){
+                return;
+            }
+            if(n == cabeza){
+                eliminaPrimero();
+            }else if (n == rabo){
+                eliminaUltimo();
+             }else{
+                n.anterior.siguiente = n.siguiente;
+                n.siguiente.anterior = n.anterior;
+                longitud --;
+            }
+        }
     }
 
     /**
@@ -177,7 +257,17 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
-        // Aquí va su código.
+        if (cabeza == null)
+        throw new NoSuchElementException("La lista es vacia");
+        T e = cabeza.elemento;
+        if(cabeza == rabo){
+            cabeza = rabo = null;
+        }else{
+            cabeza = cabeza.siguiente;
+            cabeza.anterior = null;
+        }
+        longitud--;
+        return e;
     }
 
     /**
@@ -186,8 +276,18 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
-        // Aquí va su código.
-    }
+        if(rabo==null)
+        throw new NoSuchElementException("La lista es vacia");
+        T e = rabo.elemento;
+        if(rabo.anterior == null){
+            rabo = cabeza = null;
+        }else{
+            rabo = rabo.anterior;
+            rabo.siguiente = null;
+
+    }   longitud--;
+    return e;
+}
 
     /**
      * Nos dice si un elemento está en la lista.
@@ -196,7 +296,13 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        Nodo n = cabeza;
+        while(n != null){
+            if(n.elemento.equals(elemento)) 
+                return true;
+            n = n.siguiente;
+        }
+        return false;
     }
 
     /**
@@ -204,7 +310,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> r = new Lista<T>();
+        Nodo n = cabeza;
+        while(n != null){
+            r.agregaInicio(n.elemento);
+            n = n.siguiente;
+        }
+        return r;
     }
 
     /**
@@ -213,14 +325,20 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
-        // Aquí va su código.
+        Lista<T> r = new Lista<T>();
+        for (Nodo n = cabeza; n != null; n=n.siguiente) {
+            r.agregaFinal(n.elemento);
+        }
+        return r;
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        rabo = null;
+        cabeza = null;
+        longitud = 0;
     }
 
     /**
@@ -229,7 +347,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
-        // Aquí va su código.
+        if(cabeza == null)
+        throw new NoSuchElementException("No hay elementos");
+        
+        return cabeza.elemento;
     }
 
     /**
@@ -238,7 +359,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
-        // Aquí va su código.
+        if(rabo== null)
+        throw new NoSuchElementException("No hay elementos");
+
+        return rabo.elemento;
     }
 
     /**
@@ -249,28 +373,50 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if(i < 0 || i >= this.longitud)
+        throw new ExcepcionIndiceInvalido("Indice fuera de rango");
+        Nodo n = cabeza;
+        for(int j = 0; j<i ; j++)
+            n = n.siguiente;
+        return n.elemento;
     }
 
-    /**
+    /*
      * Regresa el índice del elemento recibido en la lista.
      * @param elemento el elemento del que se busca el índice.
      * @return el índice del elemento recibido en la lista, o -1 si el elemento
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        Nodo n = cabeza;
+        for(int i =0 ; i < this.longitud ; i++){
+            if(n.elemento == elemento){
+                return i;
+            }
+            n = n.siguiente;
+        }
+        return -1;
     }
 
-    /**
+    /*
      * Regresa una representación en cadena de la lista.
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String h = "[";
+        if(cabeza != null){
+            Nodo n = cabeza;
+            for(; n.siguiente!=null; n = n.siguiente){
+                h += n.elemento.toString() + ", ";
+            }
+            n = rabo;
+            h+= n.elemento.toString();
+        }
+        h+= "]";
+        return h;
     }
 
-    /**
+    /*
      * Nos dice si la lista es igual al objeto recibido.
      * @param objeto el objeto con el que hay que comparar.
      * @return <code>true</code> si la lista es igual al objeto recibido;
@@ -280,10 +426,23 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
+        if(lista.longitud != longitud)
+        return false;
+        Nodo c = cabeza;
+        Nodo c1 = lista.cabeza;
+
+        while(c != null){
+            if(c.elemento.equals(c1.elemento)){
+            c = c.siguiente;
+            c1 = c1.siguiente;
+        }else{
+           return false; 
+        }
     }
+    return true;
+ }
 
-    /**
+    /*
      * Regresa un iterador para recorrer la lista en una dirección.
      * @return un iterador para recorrer la lista en una dirección.
      */
@@ -299,6 +458,65 @@ public class Lista<T> implements Coleccion<T> {
         return new Iterador();
     }
 
+
+
+    //Auxiliares merge
+    private Lista<T> merge(Lista<T> l1, Lista<T> l2, Comparator<T> comparador) {
+	    Lista<T> unir = new Lista<T>();
+
+	    Nodo i = l1.cabeza;
+	    Nodo d = l2.cabeza;
+
+	    while ( i != null && d != null ) {
+		    if (comparador.compare( i.elemento, d.elemento ) <= 0) {
+			    unir.agrega(i.elemento);
+			    i = i.siguiente;
+		    }else{ 
+			    unir.agrega(d.elemento);
+			    d = d.siguiente;
+		    }
+	    }
+
+	    while (i != null) { 
+		    unir.agrega(i.elemento);
+		    i = i.siguiente;
+	    }
+
+	    while (d != null) {
+		    unir.agrega(d.elemento);
+		    d = d.siguiente;
+	    }
+
+	    return unir;
+    }
+
+    private Lista<T> mergeSort(Comparator<T> comparador, Lista<T> lista) {
+	    if ( lista.longitud <= 1 ) {
+		    return lista;
+	    }
+
+	    Lista<T> der = new Lista<T>();
+	    Lista<T> izq = new Lista<T>();
+
+	    Nodo n = lista.cabeza;
+	    for ( int i = 0; i < lista.longitud; i++ ) {
+		    if ( i < ( lista.longitud / 2 ) ) {
+			    izq.agrega(n.elemento);
+			    n = n.siguiente;
+		    } else { 
+			    der.agrega(n.elemento);
+			    n = n.siguiente;
+		    }
+	    }
+
+	    
+	    izq = mergeSort(comparador, izq);
+	    der =  mergeSort(comparador, der);
+
+	    return merge(izq, der, comparador);
+    }
+
+
     /**
      * Regresa una copia de la lista, pero ordenada. Para poder hacer el
      * ordenamiento, el método necesita una instancia de {@link Comparator} para
@@ -308,7 +526,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+        return mergeSort(comparador, copia());  
     }
 
     /**
@@ -333,7 +551,14 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        Nodo n = cabeza;
+	    while ( n != null ) {
+		    if ( comparador.compare(n.elemento, elemento ) == 0 )
+			    return true;
+		    n = n.siguiente;
+	    } 
+	    
+	    return false;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index 8864077..5efc661 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,7 +22,7 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento=elemento;
         }
     }
 
@@ -43,7 +43,19 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T saca() {
-        // Aquí va su código.
+        T ele;
+        if(cabeza == null){
+            throw new NoSuchElementException("La estructura es vacía");
+        }
+        
+        if(cabeza == rabo){
+            ele = rabo.elemento;
+            cabeza = rabo = null;
+        }else{
+            ele = cabeza.elemento;
+            cabeza = cabeza.siguiente;
+        }
+        return ele;
     }
 
     /**
@@ -53,7 +65,9 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T mira() {
-        // Aquí va su código.
+        if(cabeza == null)
+            throw new NoSuchElementException("No hay nada que mirar");  
+        return cabeza.elemento;
     }
 
     /**
@@ -62,7 +76,7 @@ public abstract class MeteSaca<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -76,6 +90,20 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
+        Nodo c = cabeza;
+        Nodo c1 = m.cabeza;
+
+        while(c != null){
+            if(c1 == null) return false;
+            if(!c.elemento.equals(c1.elemento)){
+                return false;
+            }
+            c = c.siguiente;
+            c1 = c1.siguiente;
+        }
+        if(c1 != null){
+            return false;
+        }
+        return true;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..5b5ea62 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -10,8 +10,18 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
-        // Aquí va su código.
-    }
+        if ( cabeza == null )
+		return "";
+
+	String ne = "";
+	Nodo n = cabeza;
+
+	while ( n != null ) {
+		ne += n.elemento.toString() + "\n";
+		n = n.siguiente;
+	}
+	return ne;
+}
 
     /**
      * Agrega un elemento al tope de la pila.
@@ -20,6 +30,16 @@ public class Pila<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if ( elemento == null ) 
+		throw new IllegalArgumentException("No hay nada que agregar");
+
+	Nodo n = new Nodo(elemento);
+
+	if ( rabo == null ) {
+		rabo = cabeza = n;
+	} else {
+		n.siguiente = cabeza;
+		cabeza = n;
+	    }
     }
 }
